(*======================================================================

                          			DERIVE

Contains the functions needed to perform MCTAG derivations, including
the substitution and adjunction operations. See the function-specific
comments for more details on the process.

======================================================================*)

open Unify
open List
open Printf
open Basics
open Tree
open Treeset
open Links
open Argument

exception AdjoinCatClash
exception SubCatClash
exception SubTypeClash
exception NoValidPartition
(* when number of instances of a link does not match
   the number of trees expected to operate at that link *)
exception LinksTreesMismatch

(*************************************
**     	Reordering Treesets        **
**************************************)

(** Returns true if an ordered list of trees is valid, based on whether it
		satisfies two conditions: 
		(1) The categories in the ordering must match the categories of
				the parallel trees in the original treeset.
		(2) The parallel features must pass a "quick check", which checks
				if the features are compatible on a surface level without actually
				performing full unification.
		Note that any operation type mismatches will raise errors in the
		subst/adjoin functions, so there is no need to check them here. *)

let isvalid (orig:treeset) specs (ordered:t list) = 
	try for_all2 (fun t spec ->
		let ((i,add),c) = spec in
		let node = lookup add (ith orig i) in
			(* check both category and features *)
			cat t = c && fscheck node t) ordered specs
	with Invalid_argument("List.for_all2") -> raise LinksTreesMismatch ;;

(** Before executing the order function, the trees in the input treeset are
		sorted by the priority ordering specified by the user. We then generate
		all permutations of the ordered treeset in lexicographic order, which
		sorts the permutations in increasing number of out-of-order pairs, and
		return the first valid permutation generated by this method. This method 
		ensures that we return the permutation that preserves the user's preferred
		ordering as much as possible. If no valid order exists, the splitarg 
		function will raise NoValidPartition. *)

let order (orig:treeset) (l:linkindex) (set:treeset) =
	let link = spec_of_l l (treeset_links orig) in
		try Some (find (isvalid orig (get_specs link)) (perms set)) with
		| Not_found -> None ;;

(** Given a list of treesets meant to operate at a single link, we first order
		all the sets according to the specified link and original set. We then arrange
		them so that all sets meant for a single tree are in a single list. Note that
		this rearranging only has non-trivial effects for non-singleton lists, 
		i.e. when a link is "reused" by multiple treesets. 

		Example: 
			SET saw:
			[s@1@2 [np!@1] [vp@3 [v 'saw'] [np!@2]]] ;
			[t@1@2@3 [et [eet 'saw'] [e!@2]] [e!@1]].

		If we want "quickly", "apparently", and "happily" to adjoin at link 3 in the
		verb set, we would first need to order the treesets corresponding to "quickly",
		"apparently", and "happily" and then create a list that contains all the syntax
		trees of the adverbs and another list of all the semantics trees of the adverbs.
		This will allow us to perform the derivation by applying the first list to the
		vp@3 node and the second list to the t@3 node. *)

let clean (orig:treeset) (l:linkindex) (sets:treeset list) =
	(* order all sets *)
	let ordered = map (order orig l) sets in
	let extract ss i = setofts (map (fun s_opt ->
		match s_opt with
		| Some s -> nth s (i-1)
		| None -> failwith "Invalid input to clean function") ss) in (* NOT SURE!!!! *)
	let rec aux num i =
	 	if i > num then [] 
	 	else (extract ordered i)::(aux num (i+1)) in
	(* if no sets, then simply create a list of empty lists,
		 one for each tree that has the specified link *)
	if sets = [] then aux (numhaslink l orig) 1
	else aux (length (ts (hd sets))) 1 ;;

(*************************************
**  	Adjunction & Substitution  		**
**************************************)

(** Adjunction operation in MCTAG. Type errors are caught in auxfun,
		which raises InitFunction if an initial tree is applied as a function. *)

let adjoin (auxes:t list) (target:t) =
  let adjsingle t aux =
    unifyadj t aux;
    let result = (auxfun aux) t in
    	if cat t = cat result then result
     	else raise AdjoinCatClash in
  fold_left adjsingle target auxes ;;

(** Substitution operation in MCTAG. The input trees must contain 
		exactly one Init tree and an optional list of Aux trees. 
		This allows for adjunction at substitution nodes, e.g. for
		"pics of" noun phrases. *)

let subst (trees:t list) (target:t) =
  let subsingle t input =
    unifysub t input;
    if cat t = cat input then 
	    let newtfs = {top = (tfs t).top ; bot = (tfs input).bot} in
	    match input with
	    | Node _ | Var _ 	-> replace_tfs input newtfs
	    | _ 							-> raise SubTypeClash
    else raise SubCatClash in
  (* sub the first tree and adjoin the rest *)
  let ordered = initfirst trees in
  let init, auxes = hd ordered, tl ordered in
  	adjoin auxes (subsingle target init) ;;

(*************************************
**     Arranging Sets for Links     **
**************************************)

(** For a single arg, which specifies a list of sets meant to be used
		at a set of links, splitarg partitions the list into sublists that
		contain sets meant to be used at single links. *)

let splitarg (orig:treeset) (arg:arg) =
	let (lset,sets) = arg in
	let renamed = renamevars sets lset in
	let links = treeset_links orig in
	let rec aux cur_ls cur_set =
		match cur_ls with
		| [] -> []
		| l::tl ->
			let link = spec_of_l l links in
			(* k-combinations of the trees, where k = number of instances of the link *)
			let combos = combinations (length (get_specs link)) (ts cur_set) |> map setofts in
			(* try to find a valid ordering of each combo *)
			let orderedcombos = map (order orig l) combos in
			(* the possibilities, i.e. the combos of trees that have valid orderings *)
			let poss = fold_left (fun acc oc -> 
				match oc with
				| None -> acc
				| Some x -> acc@[x]) [] orderedcombos in
			(* if no possibilities, there is no valid partition *)
			if poss = [] then raise NoValidPartition 
			(* if there is a possibility, take the head of the list *)
			else
				let (good,rest) = partition (fun t -> mem t (hd poss)) (ts cur_set) in
				let larg = (Single l, clean orig l [setofts good]) in
			larg::(aux tl (setofts rest)) in
	match lset with
	| Single l -> (try [(Single l, clean orig l renamed)] with Not_found -> raise NoValidPartition)
	| Union ls -> renamed |> map (aux ls) |> flatten ;;

(** Partitions the list of input treesets across single links for all arguments. *)

let split (orig:treeset) (args:arg list) = 
	args |> map (splitarg orig) |> flatten ;;

(** Returns the list of trees for an operable site at the specified location, or
		(treeindex * address) tuple. We take advantage of the fact that all args
		with the same linkindex are ordered in parallel because of the splitarg function,
		which calls order. First, we generate this list without respect to any scope,
		and then we reorder it to match the scope ordering entered by the user (reverting
		to the default if no scope is explicitly provided). *)

let trees_for_op (ls:linkindex list) (rels:treesetlinks) (loc:treeindex * address) (singles:arg list) =
  let rec no_scope cur_ls =
		match cur_ls with
		| [] -> []
		| l::tl -> 
			let specs = get_specs (spec_of_l l rels) in
			(* generate indices for each spec *)
			let inds = inds specs in
			(* find the index that gives the loc matching the one specified by the user *)
			let i = find (fun ind -> fst (nth specs (ind-1)) = loc) inds in
			(* find the relevant arguments, i.e. the args that have the l we want *)
			let rel_args = fold_left (fun acc single ->
				match single with
				| (Single x,sets) -> if x = l then acc@[sets] else acc
				| _ -> failwith "forop: split failed") [] singles in
			(* extract the ith set from each arg in rel_args *)
			let result = map (fun r -> nth r (i-1)) rel_args in
				result::(no_scope tl) in
	let unordered = no_scope ls in
	(* get the scope ordering *)
	let scope = scope rels ls in
	(* reorder according to the scope *)
	let ordered = reorder_scope unordered scope in 
  	ordered |> map ts |> flatten ;;

(*************************************
**     	Performing Derivations     	**
**************************************)

(** Returns a single fully derived tree. At every node, we use the trees_for_op
		function to turn the args and relevant links into a list of trees ready to
		operate at that node, processed in a valid order that matches categories,
		features, and scope. The apply function is the place where we actually call
		the subst and adjoin functions. *)

let apply (t:t) (i:treeindex) (rels:treesetlinks) (singles:arg list) =
	let rec aux t cur_add =
		let ls = try ls t with NoLinks -> [] in
		let loc = (i,cur_add) in
		let input = trees_for_op ls rels loc singles in
			match t with
			| Node(c,ls,fs,kids) -> adjoin input (Node(c,ls,fs,auxts kids 1 cur_add))
			| Quant(q,v,l,r) 		 -> Quant(q,v,aux l (cur_add@[1]),aux r (cur_add@[2]))
			| Sub _ 						 -> (try subst input t with SubTypeClash -> adjoin input t)
			| Foot _ 
			| Var _ 		 				 -> adjoin input t
			| Leaf _						 -> t
	and auxts ts i parent =
		match ts with
		| [] -> []
		| t::tl -> (aux t (parent@[i]))::(auxts tl (i+1) parent) in
	aux t [] ;;

(** Performs a derivation given a set and its arguments by doing the following:
		(1) Partition each arg, or (linkset * treeset list) tuple, into sublists that
				operate at single links. We do this by generating lexicographic permutations
				of the trees, which have already been processed to fit the priority ordering
				specified by the user, and picking the first permutation that matches the original
				trees in category and features (rough match). 
		(2) Using these "singles" and matching link specifications, we derive each tree
				in the original set independently and cons them into the final derived treeset. *)

let derive (orig:treeset) (args:arg list) =
	let singles = split orig args in
	(* gets the list of link indices from the singles.
		 we can't simply use orig#links because the order will matter for scope later. *)
	let ls = map (fun single ->
		match single with
		| Single l, _ -> l
		| _ -> failwith "derive: singles failed") singles in
	let rels = rels ls (treeset_links orig) in
	let rec apply_to_ts cur i =
		match cur with
		| [] -> []
		| t::tl -> 
      (apply t i rels singles)::(apply_to_ts tl (i+1)) in
	let new_ts = apply_to_ts (ts orig) 1 in 
  	setofts new_ts ;;
